ipconfig

## Chương 1: Mở đầu

### 1.1. Giới thiệu hệ thống phân tán
Hệ thống Đăng ký Học phần là một ứng dụng phân tán cho phép sinh viên từ nhiều máy tính khác nhau có thể truy cập, xem danh sách môn học và thực hiện đăng ký vào cơ sở dữ liệu trung tâm.
*   **Mục tiêu**: Đảm bảo tính nhất quán dữ liệu khi nhiều người cùng đăng ký một lúc (Concurrency Support).
*   **Lý do triển khai phân tán**: Để phục vụ hàng nghìn sinh viên cùng lúc mà không phụ thuộc vào việc họ phải đến phòng đào tạo (Transparency & Scalability).

### 1.2. Mô tả tổng quan
Hệ thống bao gồm:
1.  **Server**: Trung tâm xử lý, lưu trữ dữ liệu lớp học, sinh viên.
2.  **Client**: Ứng dụng giao diện dòng lệnh (CLI) chạy trên máy cá nhân của sinh viên.
3.  **Database**: MySQL lưu trữ thông tin bền vững.

---

## Chương 2: Kiến trúc Phân tán & Minh chứng Code

### 2.1. Phân tán Xử lý (Client-Server)
Mô hình tách biệt giao diện và xử lý:
*   **Client Node (`client/network_client.py`)**: Chịu trách nhiệm giao diện và gửi lệnh.
    *   *Code*: `sock.connect((self.host, self.port))` (Dòng 18) - Kết nối TCP đến Server.
*   **Server Node (`server/server.py`)**: Chịu trách nhiệm logic và điều phối.
    *   *Code*: `server.bind((SERVER_HOST, SERVER_PORT))` (Dòng 10) - Mở cổng lắng nghe 8888.

### 2.2. Xử lý Đồng thời (Concurrency)
Khả năng phục vụ nhiều sinh viên cùng lúc:
*   **Multithreading (`server/server.py` & `request_handler.py`)**:
    *   *Code*: `thread = ClientThread(client_sock, client_addr)` (Server dòng 21).
    *   *Code*: `target=self.handle_client` - Mỗi Client được một luồng riêng phục vụ, không ai phải đợi ai kết nối.

### 2.3. Phân tán Dữ liệu & Đồng bộ (Consistency)
Giải quyết tranh chấp khi nhiều người cùng đăng ký:
*   **Database Locking (`server/database_manager.py`)**:
    *   *Code*: `SELECT ... FOR UPDATE` (Dòng 115) - Khóa bản ghi lớp học.
    *   *Cơ chế*: Đảm bảo khi User A đang đọc số chỗ trống, User B không thể nhảy vào sửa đổi cho đến khi A xong transaction.

---

## Chương 3: Chi tiết Kiến trúc (Cũ)

### 2.1. Đánh giá kiến trúc
Hệ thống sử dụng mô hình **Client-Server truyền thống** kết hợp với **Layered Architecture (Kiến trúc phân tầng)**.
*   **Lý do chọn**: Đơn giản, dễ triển khai cho bài toán quản lý tập trung, dễ bảo trì hơn so với Microservices (quá phức tạp cho scope đồ án này).

### 2.2. Các thành phần & Giao tiếp
Hệ thống chia làm 3 tầng rõ rệt:
1.  **Presentation Layer (Client)**: Chỉ lo hiển thị UI.
2.  **Application logic Layer (Server Controller)**: Xử lý logic nghiệp vụ.
3.  **Data Access Layer (DAO)**: Giao tiếp với Database.

Sơ đồ phân chia công việc:
*   **Client Node**: Gửi Request (Login, Register).
*   **Server Node**: Nhận Request -> Xử lý tính toán -> Gọi DB -> Trả Response.

---

## Chương 3: Tiến trình và luồng

### 3.1. Multithreading (Đa luồng)
Hệ thống sử dụng model **Thread-per-Client** bằng thư viện `threading` của Python.
*   **Cơ chế**: Server Main Thread lắng nghe ở cổng 8888. Khi có Client kết nối, nó "đẻ" ra một `ClientThread` mới.
*   **Mục đích**: Để Client A đang suy nghĩ nhập liệu không làm chặn (block) Client B đang muốn đăng ký.

```python
# Trích dẫn từ server.py
while True:
    # Vòng lặp chính của Server: Chỉ chấp nhận và điều phối
    client_sock, client_addr = server.accept()
    
    # Giao việc cho bộ xử lý (Handler)
    thread = ClientThread(client_sock, client_addr)
    thread.start()
```

### 3.2. Đồng bộ luồng
Các luồng chạy song song nhưng độc lập về bộ nhớ (mỗi luồng có 1 connection DB riêng) để tránh xung đột tài nguyên cục bộ.

```python
# Trích dẫn từ request_handler.py
class ClientThread(threading.Thread):
    def __init__(self, client_sock, client_addr):
        super().__init__()
        # ...
        # Mỗi luồng tạo một kết nối DB riêng biệt
        self.db = DatabaseManager(DB_CONFIG) 
```

---

## Chương 4: Trao đổi thông tin

### 4.1. Giao thức Transport: TCP (Transmission Control Protocol)
Hệ thống sử dụng **TCP** vì tính chất quan trọng của dữ liệu đăng ký tín chỉ:
*   **Độ tin cậy tuyệt đối**: Một gói tin "Đăng ký" không được phép mất. TCP đảm bảo gửi lại (retransmission) nếu mất gói, còn UDP thì không.
*   **Tuần tự (Ordered)**: Lệnh "Login" phải đến trước lệnh "Register". TCP đảm bảo thứ tự, UDP thì không.
*   **Kết nối bền vững (Connection-oriented)**: Client giữ kết nối liên tục với Server trong suốt phiên làm việc, không cần bắt tay lại nhiều lần.

**Minh chứng trong Code (`server.py` & `client/network_client.py`)**:
```python
# socket.SOCK_STREAM chính là hằng số đại diện cho TCP
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
```
*(Nếu dùng UDP sẽ là `socket.SOCK_DGRAM`)*

### 4.2. Giao thức ứng dụng (Custom Protocol)
Định nghĩa giao thức dạng Text-based đơn giản: `CMD|ARG1|ARG2`
*   Ví dụ Request: `LOGIN|nguyenvanA|123456`
*   Ví dụ Response: `OK|Success` hoặc `ERR|Wrong Password`

```python
# Trích dẫn từ request_handler.py
data = self.client_sock.recv(1024).decode('utf-8')
parts = data.strip().split('|')
command = parts[0]
args = parts[1:]

if command == 'LOGIN':
    response = self.handle_login(args)
elif command == 'REGISTER':
    response = self.handle_register(args)
```

Sự lựa chọn này giúp gói tin nhỏ gọn hơn JSON/XML và dễ dàng debug bằng mắt thường.

---

## Chương 5: Định danh

### 5.1. Định danh Node
*   **Server**: Được định danh bằng `IP Tĩnh` (hoặc localhost trong môi trường Lab) và `Fixed Part (8888)`.
*   **Client**: Được định danh bằng `Dynamic IP` và `Ephemeral Port` do hệ điều hành cấp phát ngẫu nhiên khi kết nối.

### 5.2. Định danh Người dùng (User Identity)
*   Sử dụng **Username** (Mã sinh viên) làm khóa chính để định danh người dùng trong phiên làm việc (Session).
*   Sau khi `LOGIN` thành công, thread xử lý sẽ gắn nhãn `self.current_user = username` để biết các lệnh tiếp theo đến từ ai.

---

## Chương 6: Đồng bộ hóa

### 6.1. Vấn đề tranh chấp (Race Condition)
Bài toán kinh điển: Còn 1 chỗ, 2 người cùng bấm Đăng ký.

### 6.2. Giải pháp: Pessimistic Locking
Dự án sử dụng cơ chế khóa của MySQL Transaction (`Concurrency Control`):
*   Câu lệnh: `SELECT ... FOR UPDATE`
*   **Hoạt động**: Khi User A đọc số lượng chỗ còn lại, hệ thống khóa dòng dữ liệu đó. User B muốn đọc phải chờ A Commit hoặc Rollback xong mới được đọc.
*   Giúp đảm bảo tính **Atomic** và **Consistency** (ACID).

```python
# Trích dẫn từ database_manager.py
# 2. Khóa và kiểm tra chỗ trống (MySQL Locking)
verify_query = "SELECT current_enrolled, max_slots FROM sections WHERE id = %s FOR UPDATE"
self.cursor.execute(verify_query, (section_id,))
section = self.cursor.fetchone()

# 3. Cập nhật và Chèn dữ liệu
if section['current_enrolled'] < section['max_slots']:
    update_sec = "UPDATE sections SET current_enrolled = current_enrolled + 1 WHERE id = %s"
    self.cursor.execute(update_sec, (section_id,))
    # ... commit ...
```

---

## Chương 7: Sao lưu

### 7.1. Database Backup
Dữ liệu được lưu trữ tập trung tại MySQL Server.
*   **Phương pháp**: Sử dụng công cụ `mysqldump` để tạo bản chụp (snapshot) dữ liệu `course_registration.sql`.
*   Có thể định kỳ chạy script sao lưu (Cron Jobs) để tránh mất mát dữ liệu khi Server hỏng ổ cứng.

---

## Chương 8: Tính chịu lỗi

### 8.1. Exception Handling (Xử lý ngoại lệ)
*   **Tại Server**: Mọi khối lệnh xử lý đều nằm trong `try...except`. Nếu 1 Client gửi gói tin rác làm lỗi code xử lý, chỉ **duy nhất** thread của Client đó bị tắt, Server chính và các Client khác vẫn chạy bình thường.
*   **Tại Client**: Có `try...except` khi kết nối Socket. Nếu Server sập, Client sẽ báo "Connection Error" thay vì crash ứng dụng.

### 8.2. Failover (Hướng phát triển)
Hiện tại hệ thống chạy Single-Master. Để tăng tính chịu lỗi, có thể triển khai:
*   **Replication**: 1 Master - 1 Slave MySQL Database để khi Master chết, Slave lên thay.
*   **Load Balancer**: Đặt HAProxy phía trước nhiều Server Code để chia tải.
